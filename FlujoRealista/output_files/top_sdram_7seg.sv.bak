`timescale 1ns/1ps

module top_sdram_7seg (
  input  logic        clk_clk,
  input  logic        reset_reset_n,

  // Conduit SDRAM
  output logic [12:0] wire_addr,
  output logic [1:0]  wire_ba,
  output logic        wire_cas_n,
  output logic        wire_cke,
  output logic        wire_cs_n,
  inout  logic [15:0] wire_dq,
  output logic [1:0]  wire_dqm,
  output logic        wire_ras_n,
  output logic        wire_we_n,

  // Display 7-segmentos (cátodo común)
  output logic        seg_a,
  output logic        seg_b,
  output logic        seg_c,
  output logic        seg_d,
  output logic        seg_e,
  output logic        seg_f,
  output logic        seg_g,
  output logic        digit_sel  // habilita el dígito
);

  // --------------------------------------------------------------------------
  // 1) Instanciamos la interfaz Avalon–MM
  avl_sdram_if sdram_if (
    .clk     (clk_clk),
    .reset_n (reset_reset_n)
  );

  // 2) Instanciamos el controlador SDRAM
  sdram dut (
    .clk_clk             (clk_clk),
    .reset_reset_n       (reset_reset_n),
    .sdram_address       (sdram_if.address),
    .sdram_byteenable_n  (sdram_if.byteenable_n),
    .sdram_chipselect    (sdram_if.chipselect),
    .sdram_read_n        (sdram_if.read_n),
    .sdram_write_n       (sdram_if.write_n),
    .sdram_writedata     (sdram_if.writedata),
    .sdram_readdata      (sdram_if.readdata),
    .sdram_readdatavalid (sdram_if.readdatavalid),
    .sdram_waitrequest   (sdram_if.waitrequest),

    .wire_addr           (wire_addr),
    .wire_ba             (wire_ba),
    .wire_cas_n          (wire_cas_n),
    .wire_cke            (wire_cke),
    .wire_cs_n           (wire_cs_n),
    .wire_dq             (wire_dq),
    .wire_dqm            (wire_dqm),
    .wire_ras_n          (wire_ras_n),
    .wire_we_n           (wire_we_n)
  );

  // --------------------------------------------------------------------------
  // 3) Escritura en SDRAM + lectura + decodificación 7-seg
  logic [3:0]    digit;       // valor 0–9
  logic [15:0]   mem_data;    // dato leído
  typedef enum logic [1:0] {IDLE, WRITE, READ, DISPLAY} state_t;
  state_t        state;

  // Almacena el patrón de segmentos según el dígito
  always_comb begin
    unique case (digit)
      4'd0: {seg_a,seg_b,seg_c,seg_d,seg_e,seg_f,seg_g} = 7'b0000001;
      4'd1:                             = 7'b1001111;
      4'd2:                             = 7'b0010010;
      4'd3:                             = 7'b0000110;
      4'd4:                             = 7'b1001100;
      4'd5:                             = 7'b0100100;
      4'd6:                             = 7'b0100000;
      4'd7:                             = 7'b0001111;
      4'd8:                             = 7'b0000000;
      4'd9:                             = 7'b0000100;
      default:                          = 7'b1111111;  // todo apagado
    endcase
  end

  // Sólo un dígito habilitado
  assign digit_sel = 1'b0; // cátodo común: 0 para encender

  // FSM secuencial
  always_ff @(posedge clk_clk or negedge reset_reset_n) begin
    if (!reset_reset_n) begin
      state    <= IDLE;
      digit    <= 4'd0;
    end else begin
      case (state)
        IDLE: begin
          // Preparamos valor (p.ej. 7)
          digit <= 4'd7;
          state <= WRITE;
        end

        WRITE: begin
          // Escribimos el dígito en la SDRAM a la dirección 0x000100
          sdram_if.write(25'h000100, {12'd0, digit});
          state <= READ;
        end

        READ: begin
          // Leemos de la misma dirección
          sdram_if.read(25'h000100, mem_data);
          digit <= mem_data[3:0];  // extraemos el nibble bajo
          state <= DISPLAY;
        end

        DISPLAY: begin
          // Mantenemos el display mostrando el dígito indefinidamente
          state <= DISPLAY;
        end

      endcase
    end
  end

endmodule
