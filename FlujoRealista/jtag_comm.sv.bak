// jtag_comm.sv
// Módulo de comunicación JTAG UART con handshake simple

module jtag_comm (
    input  logic        clk,
    input  logic        reset_n,
    
    // Status outputs para debug
    output logic        comm_active,      // Indica comunicación activa
    output logic        handshake_done,   // Handshake completado
    output logic [7:0]  last_received,    // Último byte recibido
    output logic [7:0]  status_byte       // Byte de status general
);

    // Estados de la máquina de comunicación
    typedef enum logic [2:0] {
        IDLE,
        WAIT_HELLO,
        SEND_ACK,
        WAIT_ACK_SENT,
        CONNECTED,
        ERROR
    } comm_state_t;
    
    comm_state_t current_state, next_state;
    
    // Señales del JTAG UART
    logic        av_chipselect;
    logic        av_address;      // 0 = data, 1 = control
    logic        av_read_n;
    logic        av_write_n;
    logic [31:0] av_writedata;
    logic [31:0] av_readdata;
    logic        av_waitrequest;
    
    // Registros internos
    logic [7:0]  rx_data;
    logic        data_available;
    logic        write_ready;
    logic [7:0]  tx_data;
    logic        send_byte;
    logic        byte_sent;
    
    // Constantes para el protocolo de handshake
    localparam logic [7:0] HELLO_BYTE = 8'h48;  // 'H' - Hello from PC
    localparam logic [7:0] ACK_BYTE   = 8'h41;  // 'A' - Acknowledge from FPGA
    localparam logic [7:0] READY_BYTE = 8'h52;  // 'R' - Ready for commands
    
    // Instancia del JTAG UART (Altera/Intel IP)
    altera_avalon_jtag_uart #(
        .ALLOW_MULTIPLE_CONNECTIONS(0),
        .HUBADDRESS(0),
        .READ_DEPTH(64),
        .READ_THRESHOLD(8),
        .WRITE_DEPTH(64),
        .WRITE_THRESHOLD(8)
    ) jtag_uart_inst (
        .clk            (clk),
        .rst_n          (reset_n),
        .av_chipselect  (av_chipselect),
        .av_address     (av_address),
        .av_read_n      (av_read_n),
        .av_write_n     (av_write_n),
        .av_writedata   (av_writedata),
        .av_readdata    (av_readdata),
        .av_waitrequest (av_waitrequest)
    );
    
    // Lógica secuencial principal
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            current_state <= IDLE;
            last_received <= 8'h00;
            status_byte <= 8'h00;
        end else begin
            current_state <= next_state;
            
            // Capturar último byte recibido
            if (data_available) begin
                last_received <= rx_data;
            end
            
            // Actualizar status byte según el estado
            case (current_state)
                IDLE:         status_byte <= 8'h01;
                WAIT_HELLO:   status_byte <= 8'h02;
                SEND_ACK:     status_byte <= 8'h03;
                WAIT_ACK_SENT:status_byte <= 8'h04;
                CONNECTED:    status_byte <= 8'h05;
                ERROR:        status_byte <= 8'hFF;
                default:      status_byte <= 8'h00;
            endcase
        end
    end
    
    // Máquina de estados de comunicación
    always_comb begin
        next_state = current_state;
        send_byte = 1'b0;
        tx_data = 8'h00;
        
        case (current_state)
            IDLE: begin
                next_state = WAIT_HELLO;
            end
            
            WAIT_HELLO: begin
                if (data_available && rx_data == HELLO_BYTE) begin
                    next_state = SEND_ACK;
                end else if (data_available && rx_data != HELLO_BYTE) begin
                    // Si recibimos algo que no es HELLO, seguimos esperando
                    next_state = WAIT_HELLO;
                end
            end
            
            SEND_ACK: begin
                send_byte = 1'b1;
                tx_data = ACK_BYTE;
                if (write_ready) begin
                    next_state = WAIT_ACK_SENT;
                end
            end
            
            WAIT_ACK_SENT: begin
                if (byte_sent) begin
                    next_state = CONNECTED;
                end
            end
            
            CONNECTED: begin
                // En este estado estamos listos para recibir comandos
                // Por ahora solo mantenemos la conexión
                if (data_available && rx_data == HELLO_BYTE) begin
                    // Si recibimos otro HELLO, reiniciamos el handshake
                    next_state = SEND_ACK;
                end
            end
            
            ERROR: begin
                // Estado de error - reiniciar después de un tiempo
                next_state = IDLE;
            end
            
            default: begin
                next_state = IDLE;
            end
        endcase
    end
    
    // Controlador de lectura del JTAG UART
    logic read_state;
    logic [31:0] control_reg;
    
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            read_state <= 1'b0;
            data_available <= 1'b0;
            rx_data <= 8'h00;
            av_chipselect <= 1'b0;
            av_address <= 1'b0;
            av_read_n <= 1'b1;
        end else begin
            // Por defecto, no hay datos disponibles
            data_available <= 1'b0;
            
            if (!read_state) begin
                // Leer registro de control para verificar si hay datos
                av_chipselect <= 1'b1;
                av_address <= 1'b1;    // Control register
                av_read_n <= 1'b0;
                av_write_n <= 1'b1;
                
                if (!av_waitrequest) begin
                    control_reg <= av_readdata;
                    read_state <= 1'b1;
                    av_chipselect <= 1'b0;
                    av_read_n <= 1'b1;
                end
            end else begin
                // Si hay datos disponibles, leerlos
                if (control_reg[15:0] > 0) begin  // RAVAIL field
                    av_chipselect <= 1'b1;
                    av_address <= 1'b0;    // Data register
                    av_read_n <= 1'b0;
                    av_write_n <= 1'b1;
                    
                    if (!av_waitrequest) begin
                        rx_data <= av_readdata[7:0];
                        data_available <= 1'b1;
                        av_chipselect <= 1'b0;
                        av_read_n <= 1'b1;
                    end
                end
                read_state <= 1'b0;
            end
        end
    end
    
    // Controlador de escritura del JTAG UART
    logic write_state;
    logic send_requested;
    
    always_ff @(posedge clk or negedge reset_n) begin
        if (!reset_n) begin
            write_state <= 1'b0;
            send_requested <= 1'b0;
            write_ready <= 1'b0;
            byte_sent <= 1'b0;
        end else begin
            byte_sent <= 1'b0;
            
            // Capturar solicitud de envío
            if (send_byte && !send_requested) begin
                send_requested <= 1'b1;
                write_ready <= 1'b0;
            end
            
            if (send_requested && !write_state) begin
                // Verificar si podemos escribir
                av_chipselect <= 1'b1;
                av_address <= 1'b1;    // Control register
                av_read_n <= 1'b0;
                av_write_n <= 1'b1;
                
                if (!av_waitrequest) begin
                    control_reg <= av_readdata;
                    write_state <= 1'b1;
                    av_chipselect <= 1'b0;
                    av_read_n <= 1'b1;
                end
            end else if (write_state) begin
                // Si hay espacio en el buffer de escritura
                if (control_reg[31:16] > 0) begin  // WSPACE field
                    av_chipselect <= 1'b1;
                    av_address <= 1'b0;    // Data register
                    av_read_n <= 1'b1;
                    av_write_n <= 1'b0;
                    av_writedata <= {24'h000000, tx_data};
                    
                    if (!av_waitrequest) begin
                        byte_sent <= 1'b1;
                        send_requested <= 1'b0;
                        write_ready <= 1'b1;
                        av_chipselect <= 1'b0;
                        av_write_n <= 1'b1;
                    end
                end
                write_state <= 1'b0;
            end else begin
                write_ready <= 1'b1;  // Por defecto, listo para escribir
            end
        end
    end
    
    // Señales de salida
    assign comm_active = (current_state != IDLE);
    assign handshake_done = (current_state == CONNECTED);

endmodule