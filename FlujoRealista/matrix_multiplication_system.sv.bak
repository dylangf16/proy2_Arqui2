//------------------------------------------------------------------------------
// Module: matrix_multiplication_system
// Descripción: Sistema completo de multiplicación de matrices 8x8 con:
// - Carga de matrices A (1-64) y B (64-1) en SDRAM
// - Multiplicación usando arreglo sistólico
// - Almacenamiento de resultados en SDRAM
// - Display de resultados de columna 1 con BTN2
// - Performance counters e intensidad aritmética
//------------------------------------------------------------------------------

module matrix_multiplication_system (
    input  logic           clk_clk,
    input  logic           reset_reset_n,
    input  logic           btn2,              // Botón para navegar resultados
    
    // Pines físicos hacia la SDRAM
    output logic [12:0]    wire_addr,
    output logic [1:0]     wire_ba,
    output logic           wire_cas_n,
    output logic           wire_cke,
    output logic           wire_cs_n,
    inout  logic [15:0]    wire_dq,
    output logic [1:0]     wire_dqm,
    output logic           wire_ras_n,
    output logic           wire_we_n,
    
    // Display de 7 segmentos (4 dígitos)
    output logic [6:0]     hex0,
    output logic [6:0]     hex1,
    output logic [6:0]     hex2,
    output logic [6:0]     hex3
);

    // Parámetros del sistema
    parameter DATA_WIDTH = 16;
    parameter ACC_WIDTH = 32;
    
    // Direcciones base en SDRAM
    parameter [24:0] MATRIX_A_BASE = 25'h000000;  // Matrices A: 0x000000
    parameter [24:0] MATRIX_B_BASE = 25'h000080;  // Matrices B: 0x000080  
    parameter [24:0] MATRIX_C_BASE = 25'h000100;  // Resultados C: 0x000100
    
    // Señales del controlador SDRAM
    logic [24:0] sdram_address;
    logic [1:0]  sdram_byteenable_n;
    logic        sdram_chipselect;
    logic [15:0] sdram_writedata;
    logic        sdram_read_n;
    logic        sdram_write_n;
    logic [15:0] sdram_readdata;
    logic        sdram_readdatavalid;
    logic        sdram_waitrequest;
    
    // Señales de la interfaz SDRAM simplificada
    logic        start_write;
    logic        start_read;
    logic [24:0] address;
    logic [15:0] write_data;
    logic [15:0] read_data;
    logic        operation_done;
    logic        busy;
    
    // Señales del arreglo sistólico
    logic signed [DATA_WIDTH-1:0] A_in [0:7];
    logic signed [DATA_WIDTH-1:0] B_in [0:7];
    logic signed [ACC_WIDTH-1:0]  C_out [0:7][0:7];
    logic        systolic_start;
    logic        systolic_done;
    
    // Estados principales del sistema
    typedef enum logic [3:0] {
        INIT,
        LOAD_MATRIX_A,
        LOAD_MATRIX_B,
        SYSTOLIC_COMPUTE,
        STORE_RESULTS,
        DISPLAY_RESULTS,
        IDLE
    } main_state_t;
    
    main_state_t current_state, next_state;
    
    // Estados para carga/almacenamiento de matrices
    typedef enum logic [2:0] {
        MEM_IDLE,
        MEM_WRITE_START,
        MEM_WRITE_WAIT,
        MEM_READ_START,
        MEM_READ_WAIT
    } mem_state_t;
    
    mem_state_t mem_state, next_mem_state;
    
    // Registros de control
    logic [31:0] control_reg;         // Registro de control general
    logic [31:0] status_reg;          // Registro de estado
    logic [31:0] config_reg;          // Registro de configuración
    
    // Performance counters
    logic [63:0] cycle_counter;       // Contador de ciclos totales
    logic [31:0] mem_ops_counter;     // Contador de operaciones de memoria
    logic [31:0] compute_cycles;      // Ciclos de computación
    logic [31:0] mem_access_cycles;   // Ciclos de acceso a memoria
    logic [31:0] flop_counter;        // Contador de operaciones flotantes
    
    // Contadores auxiliares
    logic [6:0]  matrix_index;        // Índice para cargar matrices (0-63)
    logic [6:0]  result_index;        // Índice para guardar resultados
    logic [2:0]  display_index;       // Índice para mostrar resultados (0-7)
    logic [3:0]  display_mode;        // 0-7: resultados, 8: intensidad aritmética
    
    // Registros para almacenar datos
    logic signed [15:0] matrix_a [0:7][0:7];
    logic signed [15:0] matrix_b [0:7][0:7];
    logic signed [31:0] column_results [0:7];
    
    // Señales de control del display
    logic        btn2_prev, btn2_edge;
    logic [31:0] display_value;
    logic [31:0] arithmetic_intensity;
    
    // Delay counter para inicialización
    logic [25:0] init_delay_counter;
    logic        init_delay_done;
    
    // Instanciación del controlador SDRAM
    sdram sdram_controller (
        .clk_clk(clk_clk),
        .reset_reset_n(reset_reset_n),
        .sdram_address(sdram_address),
        .sdram_byteenable_n(sdram_byteenable_n),
        .sdram_chipselect(sdram_chipselect),
        .sdram_writedata(sdram_writedata),
        .sdram_read_n(sdram_read_n),
        .sdram_write_n(sdram_write_n),
        .sdram_readdata(sdram_readdata),
        .sdram_readdatavalid(sdram_readdatavalid),
        .sdram_waitrequest(sdram_waitrequest),
        .wire_addr(wire_addr),
        .wire_ba(wire_ba),
        .wire_cas_n(wire_cas_n),
        .wire_cke(wire_cke),
        .wire_cs_n(wire_cs_n),
        .wire_dq(wire_dq),
        .wire_dqm(wire_dqm),
        .wire_ras_n(wire_ras_n),
        .wire_we_n(wire_we_n)
    );
    
    // Instanciación de la interfaz SDRAM simplificada
    sdram_interface sdram_if (
        .clk(clk_clk),
        .reset_n(reset_reset_n),
        .start_write(start_write),
        .start_read(start_read),
        .address(address),
        .write_data(write_data),
        .read_data(read_data),
        .operation_done(operation_done),
        .busy(busy),
        .sdram_address(sdram_address),
        .sdram_byteenable_n(sdram_byteenable_n),
        .sdram_chipselect(sdram_chipselect),
        .sdram_writedata(sdram_writedata),
        .sdram_read_n(sdram_read_n),
        .sdram_write_n(sdram_write_n),
        .sdram_readdata(sdram_readdata),
        .sdram_readdatavalid(sdram_readdatavalid),
        .sdram_waitrequest(sdram_waitrequest)
    );
    
    // Instanciación del arreglo sistólico
    SystolicArray8x8 #(
        .DATA_WIDTH(DATA_WIDTH),
        .ACC_WIDTH(ACC_WIDTH)
    ) systolic_array (
        .clk(clk_clk),
        .rst_n(reset_reset_n),
        .A_in(A_in),
        .B_in(B_in),
        .C_out(C_out)
    );
    
    // Contador de delay para inicialización
    always_ff @(posedge clk_clk or negedge reset_reset_n) begin
        if (!reset_reset_n) begin
            init_delay_counter <= 26'b0;
            init_delay_done <= 1'b0;
        end else begin
            if (init_delay_counter < 26'd50000000) begin  // ~1 segundo a 50MHz
                init_delay_counter <= init_delay_counter + 1;
            end else begin
                init_delay_done <= 1'b1;
            end
        end
    end
    
    // Performance counters
    always_ff @(posedge clk_clk or negedge reset_reset_n) begin
        if (!reset_reset_n) begin
            cycle_counter <= 64'b0;
            mem_ops_counter <= 32'b0;
            compute_cycles <= 32'b0;
            mem_access_cycles <= 32'b0;
            flop_counter <= 32'b0;
        end else begin
            // Contador de ciclos siempre incrementa
            cycle_counter <= cycle_counter + 1;
            
            // Contador de operaciones de memoria
            if (start_write || start_read) begin
                mem_ops_counter <= mem_ops_counter + 1;
            end
            
            // Contador de ciclos de acceso a memoria
            if (busy) begin
                mem_access_cycles <= mem_access_cycles + 1;
            end
            
            // Contador de ciclos de computación (durante multiplicación sistólica)
            if (current_state == SYSTOLIC_COMPUTE) begin
                compute_cycles <= compute_cycles + 1;
                flop_counter <= flop_counter + 64; // 64 MAC ops por ciclo (8x8 array)
            end
        end
    end
    
    // Cálculo de intensidad aritmética (FLOPs / Bytes transferidos)
    // Aproximación: flop_counter / (mem_ops_counter * 2) 
    // Factor 2 porque cada operación de memoria transfiere 2 bytes
    always_comb begin
        if (mem_ops_counter > 0) begin
            arithmetic_intensity = flop_counter / (mem_ops_counter << 1);
        end else begin
            arithmetic_intensity = 32'b0;
        end
    end
    
    // Registros de control y estado
    always_ff @(posedge clk_clk or negedge reset_reset_n) begin
        if (!reset_reset_n) begin
            control_reg <= 32'b0;
            status_reg <= 32'b0;
            config_reg <= 32'h00080008; // Configuración 8x8
        end else begin
            // Control register - bits de control del sistema
            control_reg[0] <= (current_state != IDLE); // Sistema activo
            control_reg[1] <= systolic_start;          // Computación sistólica activa
            control_reg[2] <= busy;                    // Memoria ocupada
            
            // Status register - estado actual del sistema
            status_reg[3:0] <= current_state;
            status_reg[7:4] <= mem_state;
            status_reg[8] <= init_delay_done;
            status_reg[15:9] <= matrix_index;
            status_reg[23:16] <= result_index;
            status_reg[31:24] <= display_mode;
        end
    end
    
    // Detección de flanco del botón
    always_ff @(posedge clk_clk or negedge reset_reset_n) begin
        if (!reset_reset_n) begin
            btn2_prev <= 1'b0;
            btn2_edge <= 1'b0;
        end else begin
            btn2_prev <= btn2;
            btn2_edge <= btn2 & ~btn2_prev;
        end
    end
    
    // Control del índice de display
    always_ff @(posedge clk_clk or negedge reset_reset_n) begin
        if (!reset_reset_n) begin
            display_mode <= 4'b0;
        end else if (btn2_edge && current_state == DISPLAY_RESULTS) begin
            if (display_mode == 4'd8) begin
                display_mode <= 4'b0; // Volver al primer resultado
            end else begin
                display_mode <= display_mode + 1;
            end
        end
    end
    
    // Máquina de estados principal
    always_ff @(posedge clk_clk or negedge reset_reset_n) begin
        if (!reset_reset_n) begin
            current_state <= INIT;
            matrix_index <= 7'b0;
            result_index <= 7'b0;
        end else begin
            current_state <= next_state;
            
            case (current_state)
                LOAD_MATRIX_A, LOAD_MATRIX_B: begin
                    if (operation_done && matrix_index < 63) begin
                        matrix_index <= matrix_index + 1;
                    end else if (operation_done && matrix_index == 63) begin
                        matrix_index <= 7'b0;
                    end
                end
                
                STORE_RESULTS: begin
                    if (operation_done && result_index < 63) begin
                        result_index <= result_index + 1;
                    end else if (operation_done && result_index == 63) begin
                        result_index <= 7'b0;
                    end
                end
            endcase
        end
    end
    
    // Lógica de transición de estados principal
    always_comb begin
        next_state = current_state;
        
        case (current_state)
            INIT: begin
                if (init_delay_done) begin
                    next_state = LOAD_MATRIX_A;
                end
            end
            
            LOAD_MATRIX_A: begin
                if (operation_done && matrix_index == 63) begin
                    next_state = LOAD_MATRIX_B;
                end
            end
            
            LOAD_MATRIX_B: begin
                if (operation_done && matrix_index == 63) begin
                    next_state = SYSTOLIC_COMPUTE;
                end
            end
            
            SYSTOLIC_COMPUTE: begin
                if (systolic_done) begin
                    next_state = STORE_RESULTS;
                end
            end
            
            STORE_RESULTS: begin
                if (operation_done && result_index == 63) begin
                    next_state = DISPLAY_RESULTS;
                end
            end
            
            DISPLAY_RESULTS: begin
                next_state = DISPLAY_RESULTS; // Permanecer en este estado
            end
            
            default: begin
                next_state = INIT;
            end
        endcase
    end
    
    // Control de operaciones de memoria y datos
    always_comb begin
        start_write = 1'b0;
        start_read = 1'b0;
        address = 25'b0;
        write_data = 16'b0;
        
        case (current_state)
            LOAD_MATRIX_A: begin
                start_write = 1'b1;
                address = MATRIX_A_BASE + matrix_index;
                write_data = matrix_index + 1; // Valores 1-64
            end
            
            LOAD_MATRIX_B: begin
                start_write = 1'b1;
                address = MATRIX_B_BASE + matrix_index;
                write_data = 64 - matrix_index; // Valores 64-1
            end
            
            STORE_RESULTS: begin
                start_write = 1'b1;
                address = MATRIX_C_BASE + result_index;
                // Almacenar resultado correspondiente
                write_data = C_out[result_index >> 3][result_index & 7][15:0];
            end
        endcase
    end
    
    // Control del arreglo sistólico (simplificado)
    logic [7:0] systolic_cycle_count;
    
    always_ff @(posedge clk_clk or negedge reset_reset_n) begin
        if (!reset_reset_n) begin
            systolic_cycle_count <= 8'b0;
            systolic_start <= 1'b0;
            systolic_done <= 1'b0;
        end else begin
            if (current_state == SYSTOLIC_COMPUTE && !systolic_done) begin
                if (!systolic_start) begin
                    systolic_start <= 1'b1;
                    systolic_cycle_count <= 8'b0;
                end else if (systolic_cycle_count < 8'd200) begin // Tiempo suficiente para completar
                    systolic_cycle_count <= systolic_cycle_count + 1;
                end else begin
                    systolic_done <= 1'b1;
                end
            end else if (current_state != SYSTOLIC_COMPUTE) begin
                systolic_start <= 1'b0;
                systolic_done <= 1'b0;
                systolic_cycle_count <= 8'b0;
            end
        end
    end
    
    // Datos para el arreglo sistólico (simplificado - valores directos)
    always_comb begin
        for (int i = 0; i < 8; i++) begin
            A_in[i] = (systolic_start) ? (i + 1) : 16'b0;
            B_in[i] = (systolic_start) ? (64 - i) : 16'b0;
        end
    end
    
    // Captura de resultados de la columna 1
    always_ff @(posedge clk_clk or negedge reset_reset_n) begin
        if (!reset_reset_n) begin
            for (int i = 0; i < 8; i++) begin
                column_results[i] <= 32'b0;
            end
        end else if (systolic_done) begin
            for (int i = 0; i < 8; i++) begin
                column_results[i] <= C_out[i][0]; // Columna 1 (índice 0)
            end
        end
    end
    
    // Selección de valor para display
    always_comb begin
        if (display_mode < 8) begin
            display_value = column_results[display_mode];
        end else begin
            display_value = arithmetic_intensity;
        end
    end
    
    // Decodificador de 7 segmentos
    function logic [6:0] hex_to_7seg(input logic [3:0] hex);
        case (hex)
            4'h0: hex_to_7seg = 7'b1000000; // 0
            4'h1: hex_to_7seg = 7'b1111001; // 1
            4'h2: hex_to_7seg = 7'b0100100; // 2
            4'h3: hex_to_7seg = 7'b0110000; // 3
            4'h4: hex_to_7seg = 7'b0011001; // 4
            4'h5: hex_to_7seg = 7'b0010010; // 5
            4'h6: hex_to_7seg = 7'b0000010; // 6
            4'h7: hex_to_7seg = 7'b1111000; // 7
            4'h8: hex_to_7seg = 7'b0000000; // 8
            4'h9: hex_to_7seg = 7'b0010000; // 9
            4'hA: hex_to_7seg = 7'b0001000; // A
            4'hB: hex_to_7seg = 7'b0000011; // b
            4'hC: hex_to_7seg = 7'b1000110; // C
            4'hD: hex_to_7seg = 7'b0100001; // d
            4'hE: hex_to_7seg = 7'b0000110; // E
            4'hF: hex_to_7seg = 7'b0001110; // F
        endcase
    endfunction
    
    // Asignación de los displays de 7 segmentos (4 dígitos)
    assign hex0 = hex_to_7seg(display_value[3:0]);    // Dígito menos significativo
    assign hex1 = hex_to_7seg(display_value[7:4]);    
    assign hex2 = hex_to_7seg(display_value[11:8]);   
    assign hex3 = hex_to_7seg(display_value[15:12]);  // Dígito más significativo

endmodule